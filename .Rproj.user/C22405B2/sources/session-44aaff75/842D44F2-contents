rm(list=ls())
source('SpatialFxs.R')
library(ggplot2)
library(lubridate)
library(dplyr)
library(sp)


# Load data, drift GPS, and noise levels pre-process, and wind lease area

# Set the directory where your CSV files are located
csv_directory <- "F:\\GPS_CSV-20230923T045356Z-001\\MorroBay Mar 2023"

# Get a list of CSV files in the directory (adjust the pattern if needed)
csv_files <- list.files(path = csv_directory, 
                        pattern = "*.csv", full.names = TRUE)

# Combine the list of dataframes into a single dataframe
GPSdf <- do.call(rbind, lapply(csv_files, read.csv))

# Add UTC coords with the sp package
cord.dec = SpatialPoints(cbind(GPSdf$Longitude,GPSdf$Latitude),
                         proj4string=CRS("+proj=longlat"))
cord.dec = spTransform(cord.dec, CRS("+init=epsg:32610"))
GPSdf$UTMx =  coordinates(cord.dec)[,1]
GPSdf$UTMy =  coordinates(cord.dec)[,2]

# Convert to datetime, create date hour column
GPSdf$UTC=as.POSIXct(GPSdf$UTC,tz = 'UTC')
GPSdf$UTCDatehour = GPSdf$UTC
minute(GPSdf$UTCDatehour)<-0
second(GPSdf$UTCDatehour)<-0


# Add noise level data
csv_directory='F:\\GPS_CSV-20230923T045356Z-001\\MorroBay Mar 2023 Noise Files'
csv_files <- list.files(path = csv_directory, pattern = "*.csv", full.names = TRUE)
dataframes_list <- list()

# Loop through each CSV file load, change name
for (csv_file in csv_files) {
  # Read the CSV file
  df <- read.csv(csv_file, header = TRUE)
  
  # Extract the first and eighth columns
  df <- df[, c(1, 8)]
  colnames(df)[1]<-'UTC'
  
  # Extract the first 10 characters from the filename
  file_name <- substr(basename(csv_file), 1, 10)
  
  # Create a 'DriftName' column with the extracted filename
  df$DriftName <- file_name
  
  # Append the dataframe to the list
  dataframes_list[[file_name]] <- df
}

# Combine all dataframes into a single dataframe
noiseDf <- bind_rows(dataframes_list)
noiseDf$datetime_posix <- as.POSIXct(noiseDf$UTC, 
                                     format = "%Y-%m-%dT%H:%M:%OSZ",
                                     tz='UTC')

# Clean out data for drifts that don't have gps or noise levels
GPSdf= subset(GPSdf, DriftName %in% noiseDf$DriftName)
noiseDf= subset(noiseDf, DriftName %in% GPSdf$DriftName)


#######################################################
# Load prediction grids and variables
##########################################################
predGridLoc ='C:\\Data\\Prediction Grids\\Grids_for_Kaitlin'
predGrid = read.csv(paste0(predGridLoc, '\\', 'CCE_0.1deg_2018-07-01.csv'))
denGridd = read.csv('C:\\Data/Prediction Grids/CCE_SDMs_2018_Bp_BiWeekly_Preds.csv')

denGridd$lat = denGridd$mlat
denGridd$lon = denGridd$mlon-360
# Trim the dnesity and the prediction grid to the region of the
# drifts

predGridSub =subset(predGrid, lat<= 36 & lat>34.5 &
                      lon >  -122.5 & lon<= -121.5) 
denGridSub = subset(denGridd, mlat<= 36 & mlat>34.5 &
                      mlon > 237.5 & mlon<= 238.5)

# Plot check
ggplot(predGrid)+
  geom_tile(aes(x= lon, y= lat, fill = ild.mean))

ggplot(denGridSub)+
  geom_tile(aes(x=mlon-360, y = mlat, fill=X74.dens.2018.07.01))+
  geom_point(data= GPSdf, aes(x=Longitude, y= Latitude), color ='yellow')
##########################################################################
# Simulate whales within the array based on density likelihood


# Simulate Source Levels(https://academic.oup.com/icesjms/article/76/1/268/5115402)
# source, level, noise level, frequen(ies), and SNR threshold
f=100:200
h=100
SLmean =190.5-10#subtracting 10 since we are in the wrong noise band
SLstdev = 7.4


# normalize the density
denGridSub$NormDen = rescale(denGridSub$X74.dens.2018.07.01)


# TDOA ERROR in seconds
ssp =1500 # soundspeed, 1500 m/s
PositionError = 1152/ssp # 80th percentile of the GPS error
SSPError = (ssp*.2)/ssp # 20% error in speed of sound
TDOA_error = SSPError+PositionError

# Allowable SNR error
SNR_error = SLstdev*1.5+TL(TDOA_error)

# create simulated calls and locations
sim.calls = data.frame()
for(ii in 1:10){sim.calls = rbind(sim.calls, 
                                  createSimWhales(denGridSub,  f, SLmean, SLstdev, h))}
sim.calls =  sim.calls[,c(1:4)]

###############################################################################
# Step through the time series and calculate the underlying N dete at each location
###############################################################################


# Create a prediction grid with lat, lon, time, drift, and noise
drifterLocs = expand.grid(DriftName =  unique(GPSdf$DriftName),
                       UTC = seq(min(GPSdf$UTC), max(GPSdf$UTC), by= '20 min'))
drifterLocs$Lat=NaN
drifterLocs$Lon =NaN
drifterLocs$NL = NaN

# Fill in the drifter information
# Make the lat/lon noise predictions 
DriftNames = unique(drifterLocs$DriftName)
for(drift in DriftNames){
  
  GPSsub = subset(GPSdf, DriftName == drift)
  NLsub =  subset(noiseDf, DriftName==drift)
  
  UTMflon <- approxfun(GPSsub$UTC, GPSsub$Longitude)
  UTMflat <- approxfun(GPSsub$UTC, GPSsub$Latitude)
  NL_FUN <-  approxfun(NLsub$datetime_posix, NLsub$TOL_500)
  
  drifterLocs$NL[drifterLocs$DriftName==drift] = 
    NL_FUN(drifterLocs$UTC[drifterLocs$DriftName==drift])
  drifterLocs$Lat[drifterLocs$DriftName==drift] = 
    UTMflat(drifterLocs$UTC[drifterLocs$DriftName==drift])
  drifterLocs$Lon[drifterLocs$DriftName==drift] = 
    UTMflon(drifterLocs$UTC[drifterLocs$DriftName==drift])
  
  print(drift)
}

#################################################################


timeSteps = unique(drifterLocs$UTC)
SL = c(SLmean-SLstdev,SLmean+SLstdev)

# Preallocate the lat/lon grid
gridArea = expand.grid(Lat = seq(min(denGridSub$lat),
                                 max(denGridSub$lat), 
                                 length.out =80),
                       Lon = seq(min(denGridSub$lon), 
                                 max(denGridSub$lon), 
                                 length.out =80))
gridArea$cellId =paste0(gridArea$Lat,
                        gridArea$Lon)



# For each timestep, figure out the density
for(ii in 1:length(timeSteps)){
  
  # Drifter subset, lat, long time
  drifterLoc = subset(drifterLocs, UTC == timeSteps[ii] & !is.na(NL) & !is.na(Lat)) 
  
  
  # Step through each drift to get the probability of detection
  detectionGrid = rep(0, nrow(gridArea))
  gridArea$Pdet = 0
  
  # Determine the detectable area, sum up all of the detection areas
  for(jj in 1:nrow(drifterLoc)){
    
    # This function returs a grid indicating which cells were 'monitored'
    # by an instrument at sensor lat/lon under a give source level range, ambient
    # noise level, and SNR threshold
    dataOut = acceptedSNR_AreaMonitored(SL=SL, 
                                        SNRthresh = 30, 
                                        NL=drifterLoc$NL[jj],
                                        senLat = drifterLoc$Lat[jj],
                                        senLon = drifterLoc$Lon[jj],
                                        whaleGrid = gridArea) 
    gridArea$Pdet= gridArea$Pdet+dataOut$Pdet
    # Plot check
    #ggplot(gridArea)+geom_tile(aes(y=Lat, x=Lon, fill = Pdet))
  }
  
  
  # Pull out the calls in the snapshot period
  snapShotCalls = subset(sim.calls, UTC> timeSteps[ii]-minutes(30) &
                           UTC< timeSteps[ii]+minutes(30))
  
  # If there were any detected animals, figure out where they could be. 
  if(nrow(snapShotCalls)>1){
    
    
    # Step through each of the calls in the snapshot
    for(jj in 1:nrow(snapShotCalls)){
      
      ########################################################################
      # Distance and arrival SNR between each of the drifters and the 
      # simulated call (truth)
      drifterLoc$r = haversine_dist(snapShotCalls$Lon[jj], snapShotCalls$Lat[jj],
                                    drifterLoc$Lon, drifterLoc$Lat)
      drifterLoc$SNR = snapShotCalls$SL[jj]-TL(drifterLoc$r)-drifterLoc$NL
      drifterLoc$CallArrivalTime = snapShotCalls$UTC[jj]+seconds(drifterLoc$r/1500)
      drifterLoc$Detected = ifelse(drifterLoc$SNR>SNRthresh,1,0)
      
      ########################################################################
      
      # If missed by all instruments, don't bother otherwise use SNR and TDOA
      # to estimate locations
      
      if(any(drifterLoc$SNR>SNRthresh)){
        
        # Figure out where the call could have come from using SNR and TDOA
        
        # Which areas were monitored? 
        dataOut = acceptedSNR_AreaMonitored(SL=SL, SNRthresh = 30, 
                                            NL=drifterLoc$NL[jj],
                                            senLat = drifterLoc$Lat[jj],
                                            senLon = drifterLoc$Lon[jj],
                                            whaleGrid = gridArea,
                                            SNR_observed =0)
        
        # Determine the accepted locations based on TDOA and SNR
        whaleGrid = calcWhaleGrid(SL, SNRthresh, drifterLoc, gridArea)
        
        
      }
      
    }
    
  }
  
}

